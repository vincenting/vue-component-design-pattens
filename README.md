## Vue 组件的设计模式 
> Vue component design patterns.

为什么要写这样一系列文章？

当前端的页面结构还是在服务器端渲染的时候，我们通过拆分模板复用 html 块的方式去思考代码的复用。例如在编辑和创建页面我们都会用到相同的一个表单，于是我们抽出 form 的代码放到 `_.form.html` 里面，并且在代码里面增加外部变量的处理让他可以同时支持两个地方的调用。例如一下选于 Rails 的一段代码：

```ruby
<%= form_for @article, url: {action: "create"} do |f| %>
  <%= f.text_field :title %>
  <%= f.submit @article.created_at  ? " Update " : " Create" %>
<% end %>
```

随着前端交互逐渐变得复杂，聪明的前端工程师们又开始思考如何去组织交互代码。因为处在 jQuery 最辉煌的年代，所以首选都是写 jQuery 插件。

```javascript
function($) {
  $.fn.pluginName = function(options) {
  // 根据传入的参数去使用 jQuery 操作 dom。
  };
})(jQuery)
```

我们针对不同的节点去使用相同的插件，并且传入不同的参数去支持多样化。业务越来越复杂，为了更好的控制界面，前端开发们开始通过字符串拼接的方式，例如 `var html = "<div class='datepick__wrapper__title'>" + str + "</div>"`，来取得了界面 html 输出的部分控制权。因为这种维护方式相对较为繁琐，后来涌现出了很多前端的模板引擎来简化在前端进行部分 html 代码的渲染工作。

虽然上面两种方式截然不同，但是，你会发现，当你去思考如何复用你的界面或者交互的时候，你需要在外围传入参数来实现多样化。和编程一样，当你需要复用某个代码块的时候，第一反应都是提取出一个方法，方法通常都有参数。最终上面的内容可以简化为 `const html = fn(optioins)`。抽象方法增加了原代码块的复杂度，但是却减少了复制粘贴代码的需要。

2010 后的几年是一个百花争放的年代。BackboneJS Angular EmberJS Sass Less Grunt Glup React Webpack 等等等各种各样的新技术入雨后春笋班涌入我们的世界，每天打开博客都会发现充斥着这些新的术语。全球包括中国的浏览器的更新加速了各种各样新技术的普及。“工程化”这个词语组件在前端开发人员中讨论。

我们关注如何如何让开发人员更简单的控制页面的更新。从早期的手动修改 dom，到后来的脏数据检测或者是其他监听数据变化的方式来自动的更新 dom 结构，再到后来虚拟 Dom 的提出，现在我们甚至可以在不关注何时更新 dom 的前提下去进行业务的开发。我们越来越关注数据，界面的更新也越来越智能，于是这个时候有聪明的人提出了 `const view = fn(state)`。

这个时候，如果把组件类比于我们代码里面的方法，你会发现我们的界面其实是有很多很多的 `fn` 方法，通过每个框架提供的组件间通信的机制耦合在一起的庞然大物。于是有一个问题，我们如何去设计我们的组件（方法）？从而让我们项目可维护性更高，更容易拓展。

我们将眼光转向更大的软件开发领域，在几十年的软件开发历史里面，前人总结了很多设计思想，就是大家每天都听到的设计模式。相对于预先（up-front）设计中使用模式，本书更加推荐使用“通过重构实现模式、趋向模式、去除模式”来实现更好的代码，而且为了减少抵触，请谨记 **模式的实现方式有很多种，本书给出的实现仅为众多实现中的一种**，所以请不要怀疑你的代码。

除了上面提到的内容，在开始阅读之前，同样希望你可以记住以下的内容：
1. 趋向模式设计时并不一定会使代码量变少；
2. 趋向模式设计并不意味着代码的易读性增加，易读性的增加需要代码的阅读者对你使用的设计模式有着一定的熟悉度，“哇，原来你用的是这种模式来保证组件的可拓展性的，我知道了！”。

所以，本书将使用 Vue@2.4 以及 webpack@3 作为例子来阐述设计模式。尽可能给出特定的业务场景，以及最简单的设计方式，然后分析可以趋向于设计的模式，以及改模式的优点以及可能带来的问题，然后再去实现对应的模式。

2017年8月于苏州